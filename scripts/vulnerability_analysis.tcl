# Copyright 2023 ETH Zurich and University of Bologna.
# Solderpad Hardware License, Version 0.51, see LICENSE for details.
# SPDX-License-Identifier: SHL-0.51
#
# Author: Luca Rufer (lrufer@student.ethz.ch)

# Description: This script uses the fault injection script and the termination
#              monitor to determine the vulnerability of a curcuit to injected
#              faults (bit flips).
#              The script first runs the testbench without an injected error
#              to get a 'golden model' for the execution time and the final
#              internal state.
#              After creating the golden model, the script resets the simulation
#              and starts the testbench again and injects exactly one fault into
#              the simulation. The vulnerability analysis uses the
#              'inject_fault.tcl' script to inject faults. ***It is in the
#              responsibility of the user to configure the settings for the
#              fault injection***.
#              While the simulation is running and an errors is injected, the
#              script checks for the following 5 termination causes using the
#              termination monitor:
#               0) The termination monitor reports that the simulation
#                  terminated without errors and the internal state of the
#                  simulation with fault injections matches the internal state
#                  of the golden model. This case is the 'Correct' case.
#               1) The termination monitor reports that the simulation
#                  terminated without errors, but the internal state of the
#                  is not the same as the golden model. This case is the
#                  'Latent' case, as it terminated corretly, but more errors
#                  migth occur if the programm is allowed to continue running.
#               2) The termination monitor reports a program termination with an
#                  'Incorrect' signal.
#               3) The termination motitor reports an exception, or an invalid
#                  state ('x' or 'z') is detected on any other termination
#                  monitor signal.
#               4) The simulation takes more than 20% longer to finish the
#                  simulation compared to the golden model, indicating that
#                  the simulation is stuck in an infinite (or very long) loop,
#                  or encountered a dead-lock.
#              For every run of the vulnerability analysis the injection seed,
#              net name, injection time, termination time and the termination
#              cause is logged.

# ============ List of variables that may be passed to this script ============
# Any of these variables may not be changed while the vulnerability analysis
# is running, unless noted otherwise. Changing any of the settings during
# runtime may result in undefined behaviour.
# ---------------------------------- General ----------------------------------
# 'verbosity'         : Controls the amount of information printed during script
#                       execution. Possible values are:
#                       0 : No statements at all
#                       1 : Only important initializaion information
#                       2 : Important information and termination status of
#                           the running programm (Recommended). Default
#                       3 : All information that is possible
# 'initial_run_proc' :  User-defined procedure to be sourced before the
#                       execution of the golden model. The script should end
#                       with some form of the 'run' command to start running
#                       the simulation. If this setting is not provided by the
#                       user, then this script simply executes 'run -all'
# 'script_base_path'  : Base path of all the scripts that are sourced here:
#                        - termination_monitor.tcl
#                        - inject_fault.tcl
#                       Default is set to './'
# --------------------------- Vulnerability Analysis --------------------------
# 'initial_seed'      : The initial random seed that is used for the random time
#                       and net selection for the fault injection. The seed is
#                       increased for every injection test round.
#                       The default value is 12345.
# 'max_num_tests'     : Maximum number of tests. Default is 1.
# 'internal_state'    : A list of signals that compose the internal state of
#                       the simulated circuit. This list of signals is used
#                       to check for latent erorrs in simulations with an
#                       injected error. If internal state check is not required,
#                       leave this list empty (default).
# 'earliest_injection_time' : The earliest time the fault may be injected into
#                       the simulation. Default is 0.
# 'latest_injection_time' : The latest time the fault may be injected into
#                       the simulation. If set to 0, this variable will be
#                       set to the execution time of the golden model (Default).
#                       If set to a negative number, this variable will be
#                       changed to the execution time of the golden model plus
#                       this negative number.
# ------------------------ Termination Monitor Signals ------------------------
# 'correct_termination_signal' : Path to the testbench signal that indicates
#                       a correct termination of the simulation. Note that an
#                       'x' or 'z' on this signal is interpreted as an
#                       exception. This parameter MUST be provided by the user
#                       and has no default value.
# 'incorrect_termination_signal' : Path to the testbench signal that indicates
#                       an incorrect termination of the simulation. Note that an
#                       'x' or 'z' on this signal is interpreted as an
#                       exception. If no net is given for this signal, the same
#                       signal as for the exception monitoring is used.
# 'exception_termination_signal' : Path to the testbench signal that indicates
#                       an exception occured in the simulation. Note that an
#                       'x' or 'z' on this signal is also interpreted as an
#                       exception. This parameter MUST be provided by the user
#                       and has no default value.
# 'custom_termination_signal_list' : List of paths to some testbench signal that 
#                       indicate some other form of termination of the simulation 
#                       if asserted. For example that the calculation would be 
#                       restarted, detected the fault, or self-corrected.
#                       Note that an 'x' or 'z' on this signal is interpreted 
#                       as an exception. Optional.
# ------------------------------ Logging Settings -----------------------------
# 'log_latent_errors' : Log the internal state comparison results if the
#                       simulation terminates with id 1. For each mismatch,
#                       a new file is created.
#                       0 : Don't log the internal state comparison results
#                           (Default)
#                       1 : Log the internal state comparison results.
# 'log_net_list'      : A list of paths to nets that are to be logged during the
#                       simulation. If this list is empty, no nets are logged
#                       (Default).
# 'save_wlf_id_list'  : Save the logged waveforms of a completed injection
#                       simulation into a injection_<seed>.wlf file if it's
#                       termination id is in 'save_wlf_id_list'.
#                       Example: Setting 'save_wlf_id_list' to {2 3 4} will save
#                       the waveforms of all injected simulations that end with
#                       an incorrect result, an exception or a timeout.
#                       If the list is not empty, the waveforms of the golden
#                       model will also be saved as 'golden.wlf'.
#                       If this list is not empty, the simulation must log some
#                       signals, either in the 'initial_run_proc' or using the
#                       'log_net_list'.
#                       By default, this list is empty.
# 'monitor_signal_list' : A list of signals to be monitored during the fault
#                       injection. This script will count the number of times
#                       the signal changed its value and add this number to the
#                       vulnerability analysis log. Every entry in the list
#                       has the format {<User_Name> <path_to_signal>}.
#                       <User_Name> is an identifier chosen by the user that
#                       will be shown in the header of the logfile for the user
#                       and must be unique, as it is used as an identifier. The
#                       <path_to_signal> is the path to the signal (including
#                       the signal) that is to be monitored.
#                       For example: setting 'monitor_signal_list' to
#                       {{"Trig" /tb/dut/trig} {"Error" /tb/error}} will add
#                       "[...],monitors{Trig Error}" to the header and add
#                       for example "[...],{12 0}" to each entry in the logfile
#                       when /tb/dut/trig changed its value 12 times and
#                       /tb/error never changed its value during the script.
#                       Note that any change before 'earliest_injection_time'
#                       is not recorded.
#                       By default, this list is empty.
# --------------------------- Manual Mode Settings ----------------------------
# 'show_waves'        : Show the waves of the nets where faults can be injected
#                       in the default wave window.
#                       0 : Don't log and show the waves (default).
#                       1 : Log and show the waves.
# 'show_fault_in_waves' : Focus the currently active cursor in the currently
#                       active wave window to the time instance where the fault
#                       was injected. This can make debugging faster in manual
#                       mode.
#                       0 : Do not modify cursor and wave windows (default).
#                       1 : Focus the cursor and window time to the fault
#                           injection.
# ------------------------------- Parallel Mode -------------------------------
# 'thread_id'         : Indicates the ID of the current thread. Must be a
#                       non-negative integer smaller than 'num_threads' and must
#                       be unique for every parallel thread. The tread ID
#                       influences the seed that is used for the fault
#                       injection, and the name of the log file. Note that ALL
#                       variables (except for 'thread_id') given to this script
#                       must be equal for ALL parallel threads. The default
#                       value is 0.
# 'num_threads'       : Number of threads that are executing in parallel. The
#                       workload is statically divided amongst all threads. It
#                       is in the responsibility of the user to create
#                       'num_threads' threads that execute the workload.
#                       If the workload is not parallellized and only executed
#                       by a single thread, set 'num_threads' to 1 (default).
# ----------------------------- Underlying Scripts -----------------------------
# In addition, the following settings from inject_fault.tcl (documented there)
# shoud / could be set:
#
# - Flip settings (mandatory):
#   - 'allow_multi_bit_upset' 
#   - 'use_bitwidth_as_weight' 
#   - 'reg_to_sig_ratio'
#   - 'signal_fault_duration' 
#   - 'register_fault_duration' 
#   - 'max_num_fault_inject'
# 
# - Periodic Fault injection settings (not mandatory):
#   - 'injection_clock'
#   - 'injection_clock_trigger'
#   - 'fault_period'
#   - 'rand_initial_injection_phase'
#
# - Statistics (not mandatory):
#   - 'log_injections'
#   - 'print_statistics'
#
# - Additional Checks (not mandatory):
#   - 'check_core_output_modification' 
#   - 'output_netlist'    
#   - 'check_core_next_state_modification' 
#   - 'next_state_netlist'
#
# - Additional Netlists (not mandatory):
#   - 'assertion_disable_list'

##################################
#  Set default parameter values  #
##################################

proc run_all {} {run -all}

# General
if {![info exists ::verbosity]}        { set ::verbosity              2 }
if {![info exists ::initial_run_proc]} { set ::initial_run_proc run_all }
if {![info exists ::script_base_path]} { set ::script_base_path    "./" }

# Vulnerability Analysis
if {![info exists ::initial_seed]}            { set ::initial_seed        12345 }
if {![info exists ::max_num_tests]}           { set ::max_num_tests           1 }
if {![info exists ::internal_state]}          { set ::internal_state     [list] }
if {![info exists ::earliest_injection_time]} { set ::earliest_injection_time 0 }
if {![info exists ::latest_injection_time]}   { set ::latest_injection_time   0 }

# Termination Monitor Signals
if {![info exists ::correct_termination_signal] || \
    ![info exists ::exception_termination_signal]} {
  echo "\[Vulnerability Analysis\] Error: some mandatory variables were not set."
  quit -code 1
}
if {![info exists ::incorrect_termination_signal]} \
  { set ::incorrect_termination_signal $::exception_termination_signal }

# Logging Settings
if {![info exists ::log_latent_errors  ]} { set ::log_latent_errors        0 }
if {![info exists ::log_net_list       ]} { set ::log_net_list        [list] }
if {![info exists ::save_wlf_id_list   ]} { set ::save_wlf_id_list    [list] }
if {![info exists ::monitor_signal_list]} { set ::monitor_signal_list [list] }

# Manual Mode Settings
if {![info exists ::show_waves         ]} { set ::show_waves          0 }
if {![info exists ::show_fault_in_waves]} { set ::show_fault_in_waves 0 }

# Parallel Mode
if {![info exists ::thread_id   ]} { set ::thread_id   0 }
if {![info exists ::num_threads ]} { set ::num_threads 1 }

######################################
#  Termination monitor return procs  #
######################################

# Post-process the id that was returned from the fault monitor
proc vulnerability_process_termination_id {id} {
  # If terminated correctly, check internal state
  if {$id == 0} {
    # Examine the final state
    set final_state [list]
    foreach net $::internal_state {
      set reg_val [examine $net]
      lappend final_state $reg_val
    }
    # Check for any mismatches compared to the golden model and save the
    # indexes to a list
    set state_mismatches [list]
    for {set i 0} { $i < [llength $::internal_state] } { incr i } {
      if {[lindex $::golden_model_final_state $i] != [lindex $final_state $i]} {
        lappend state_mismatches $i
      }
    }
    # Report if mismatches were found
    if {[llength $state_mismatches] != 0} {
      # Change id if state mismatches were found
      set id 1
      if {$::verbosity >= 2} {
        echo "\[Vulnerability Analysis\] Internal state check failed:"
        foreach i $state_mismatches {
          set final_state_net_val [lindex $final_state $i]
          set golden_model_net_val [lindex $::golden_model_final_state $i]
          echo " - [lindex $::internal_state $i] : expected $golden_model_net_val, got $final_state_net_val."
        }
      }
      # Log the internal state mismatch, if enabled
      if {$::log_latent_errors} {
        # Create the Logfile
        set file_name "latent_error_$::seed.csv"
        set latent_error_log [open $file_name w+]
        # Add the content
        puts $latent_error_log "internal_state_netname,golden_final_state,injected_final_state"
        foreach i $state_mismatches {
          set netname [lindex $::internal_state $i]
          set final_state_net_val [lindex $final_state $i]
          set golden_model_net_val [lindex $::golden_model_final_state $i]
          puts $latent_error_log "$netname,$golden_model_net_val,$final_state_net_val"
        }
        # Close the file
        close $latent_error_log
      }
    } else {
      if {$::verbosity >= 2} {
        echo "\[Vulnerability Analysis\] State check successful."
      }
    }
  }
  return $id
}

# Termination proc for the golden model (called by Termination Monitor)
proc golden_model_termination_report {id} {
  # Check that the golden model finished correctly
  if {$id != 0} {
    if {$::verbosity >= 2} {
      echo "\[Vulnerability Analysis\] Error: Golden Model did not terminate correctly."
    }
    quit -code 1
  } else {
    # Record the execution time of the golden model
    set ::golden_model_execution_time $::now
    if {$::verbosity >= 2} {
      echo "\[Vulnerability Analysis\] Golden model finished within $::golden_model_execution_time ps."
    }
    # Record the final state of the golden model
    set ::golden_model_final_state [list]
    foreach net $::internal_state {
      set reg_val [examine $net]
      lappend ::golden_model_final_state $reg_val
    }
  }
  # Indicate that the monitor was triggered (helps to rule out assertions)
  set ::monitor_triggered 1
}

# Termination proc for the injected simulation (called by Termination Monitor)
proc injection_termination_report {id} {
  # Post-process the id
  set id [vulnerability_process_termination_id $id]

  if {$::verbosity >= 2} {
    echo "\[Vulnerability Analysis\]\
          Flipped $::last_flipped_net at time $::injection_time.\
          Injection terminated with id $id at time $::now."
  }

  if {$id != 0} {
    incr ::num_tests_failed
  }

  # Extract all toggle counts
  set monitor_signals_toggle_count ""
  for {set i 0} { $i < [llength $::monitor_signal_list] } { incr i } {
    if {$i != 0} {append monitor_signals_toggle_count " "}
    set signal_name [lindex [lindex $::monitor_signal_list $i] 0]
    append monitor_signals_toggle_count [dict get $::monitor_signals_toggle_dict $signal_name]
  }

  # Log the results
  puts $::vulnerability_log [format "%010u,%01d,%09u,%09u,%s,{%s}" $::seed $id $::injection_time $::now $::last_flipped_net $monitor_signals_toggle_count]
  flush $::vulnerability_log

  # Check if the waves should be saved
  if {[lsearch $::save_wlf_id_list $id] != -1} {
    set filename "injection_$::seed.wlf"
    dataset save sim $filename
  }

  # Indicate that the monitor was triggered (helps to rule out assertions)
  set ::monitor_triggered 1
}

###################
#  Utility Procs  #
###################

proc get_random_injection_time {} {
  set low $::earliest_injection_time
  set high $::latest_injection_time
  return [expr $low + int(rand() * ($high - $low))]
}

proc wait_for_file {file_name {check_period_ms 2000}} {
  while {[catch {open $file_name r}]} {
    after $check_period_ms {set file_ready 1}
    vwait file_ready
  }
}

#################################
#  Vulnerability Analysis Round #
#################################

proc vulnerability_analysis_fault_round {} {
  # Restart the simulation
  if {$::verbosity >= 1} {
    echo "\[Vulnerability Analysis\] Reached End of simulation. Restarting..."
  }

  # Restore the simulation to startup
  restore $::checkpoint_name

  # Reset the RNG
  expr srand($::seed)

  set ::injection_time [get_random_injection_time]
  set ::forced_injection_times [subst {$::injection_time}]

  # Restart the fault injection script
  restart_fault_injection

  # Restart the termination monitors
  termination_reset_monitors

  # Restart the signal monitor counter dict
  set ::monitor_signals_toggle_dict [dict create]
  foreach sig_info $::monitor_signal_list {
    foreach {sig_name sig_path} $sig_info {}
    dict set ::monitor_signals_toggle_dict $sig_name 0
    when -label signal_monitor_${sig_name} "\$now > 0 && $sig_path" "dict incr ::monitor_signals_toggle_dict $sig_name"
  }

  # Run the simulation
  while {[eqTime $::now $::earliest_injection_time]} {run -all}

  # --- Wait for the simulation to finish ---

  # Make sure the stop was triggered by a monitor, otherwise end the script
  # and let the user take over
  if {!$::monitor_triggered} { exit }
  set ::monitor_triggered 0

  incr ::num_tests_finished
  if {$::verbosity >= 2} {
    echo "\[Vulnerability Analysis\] Current vulnerability: \
          $::num_tests_failed/$::num_tests_finished."
  }

  # Manual Mode options
  if {$::show_fault_in_waves} {
    # move the cursor to the injection time
    wave cursor time -time $::injection_time
    # move the wave window to the cursor
    wave cursor see -at 50
  }

  # Increase the seed for the next iteration
  incr ::seed $::num_threads
}

###############################################
#  Main Thread of the Vulnerability Analysis  #
###############################################

# create a list containing all monitored signals
set monitor_signals_names ""
for {set i 0} { $i < [llength $::monitor_signal_list] } { incr i } {
  if {$i != 0} {append monitor_signals_names " "}
  append monitor_signals_names [lindex [lindex $::monitor_signal_list $i] 0]
}

# Create the log file
set time_stamp [exec date +%Y%m%d_%H%M]
if {$num_threads > 1} {
  set filename "vulnerability_${time_stamp}_${::thread_id}.csv"
} else {
  set filename "vulnerability_$time_stamp.csv"
}
set ::vulnerability_log [open $filename w+]
puts $::vulnerability_log "seed,termination_cause,injection_time,termination_time,injected_net_name,monitors{${monitor_signals_names}}"

# Create the monitor triggered variable
set ::monitor_triggered 0

# === Step 1: Configure the golden model ===

# Configure the monitor settings for the golden model
set ::termination_signal_list [subst { \
  { 3 $::exception_termination_signal "Exception" } \
  { 2 $::incorrect_termination_signal "Incorrect" } \
  { 0 $::correct_termination_signal   "Correct"   }}]

# Add custom termination types with higher id (lower priority)
# Lowest ID that can be used is 5 (4 is Timeout)
set custom_signal_counter 1
foreach signal_var $::custom_termination_signal_list {
    set signal_id [expr {4 + $custom_signal_counter}]
    set signal_name "Custom $custom_signal_counter"
    echo "\[Vulnerability Analysis\] Added custom termination signal $signal_var with Name $signal_name and ID $signal_id"
    lappend ::termination_signal_list [subst { $signal_id $signal_var "$signal_name"}]
    incr custom_signal_counter
}

# Report x and z as exception
set ::termination_report_x_as_id 3

# Set the termination callback proc
set ::termination_report_proc golden_model_termination_report

# Setup the monitors
source [subst ${::script_base_path}termination_monitor.tcl]

# Log the waves
if {$::num_threads != 1} {
  set WLFFilename vsim_${::thread_id}.wlf
}

if {[llength $log_net_list] != 0} {
  log $log_net_list
}

# Disable toggle statistics
toggle disable -all

# Setup manual mode
if {$::show_waves} {
  foreach net $::inject_register_netlist { add wave $net }
  foreach net $::inject_signals_netlist  { add wave $net }
}

# Create the when for checkpointing
when -label create_checkpoint "\$now == $::earliest_injection_time" {
  stop
  nowhen create_checkpoint
}

# Run the initial run proc
$::initial_run_proc

# Create a checkpoint of the simulation
if {$::verbosity >= 2} {
  echo "\[Vulnerability Analysis\] Creating checkpoint..."
}
if {$num_threads > 1} {
  set ::checkpoint_name "startup_${thread_id}.cpt"
} else {
  set ::checkpoint_name "startup.cpt"
}
checkpoint $::checkpoint_name

# Finish the golden model
run -all

# --- wait for the golden model to finish ---

# check that the stop after the run was triggered by a monitor
if {!$::monitor_triggered} { exit }
set ::monitor_triggered 0

# Check if the waves of the golden model should be saved
if {[llength $::save_wlf_id_list] != 0} {
  dataset save sim gold.wlf
}

########################
#  Find vulnerability  #
########################

set ::num_tests_finished 0
set ::num_tests_failed 0

# update the termination monitor with an appropriate timeout
set timeout_monitor [expr round($::golden_model_execution_time * 1.2)]
lappend ::termination_signal_list [subst {4 "@$timeout_monitor" "Timeout"}]
set ::termination_report_proc injection_termination_report
termination_reset_monitors

# update the latest injection time
if {$::latest_injection_time <= 0} {
  set ::latest_injection_time [expr $::latest_injection_time + $::golden_model_execution_time]
  if {$::verbosity >= 2} {
     echo "\[Vulnerability Analysis\] Set latest injection time to $::latest_injection_time."
  }
}

# Source the fault injection script to start fault injection
# The parameters for the fault injection script have to be set up by the user,
# but some are explicitly set here:
set ::seed [expr $::initial_seed + $::thread_id]
set inject_start_time $::earliest_injection_time
set inject_stop_time $::latest_injection_time
set forced_injection_times [list]
set forced_injection_signals [list]
set ::include_forced_inj_in_stats 1
source [subst ${::script_base_path}inject_fault.tcl]

# Execute the tests
set thread_num_tests [expr ($::max_num_tests / $::num_threads)]
if {$::thread_id < ($::max_num_tests % $::num_threads)} {
  incr thread_num_tests
}
for {set i 0} { $i < $thread_num_tests } { incr i } {
  vulnerability_analysis_fault_round
}

if {$::verbosity >= 1} {
  echo "\[Vulnerability Analysis\] Reached the end of the automatic \
        vulnerability analysis. You can manually run more test by running \
        'vulnerability_analysis_fault_round'."
}
